==== About

source site is https://golangify.com/single-record-sql-queries

==== Обработка ошибок используя errors.Is()

В коде мы использовали функцию *errors.Is()*, которая была введена в Go 1.13, чтобы проверить ее точный тип.

Обсудим данный вопрос немного подробнее.

Во-первых, *sql.ErrNoRows* является примером так называемых предопределённых ошибок, которые мы можем приблизительно определить как объект error, хранящийся в глобальной переменной. Обычно они создаются с помощью функции errors.New(). Несколько примеров 'error' из стандартной библиотеки — *io.ErrUnexpectedEOF* и *bytes.ErrTooLarge*.

Только что созданная нами ошибка *models.ErrNoRecord* является примером предопределённой ошибки. У нас есть её «имя» и мы можем «ловить» её в случае если она возникнет при работе программы.

В старых версиях Go (до 1.13) лучший способ проверить, если ошибка совпадает с предопределённой ошибкой, выглядел бы так:

[source, go]
----
if err == sql.ErrNoRows {
    // Do smt
} else {
    // Do smt another
}
----

Однако после Go 1.13 лучше использовать функцию *errors.Is()*:

[source, go]
----
if errors.Is(err, sql.ErrNoRows) {
    // Do smt
} else {
    // Do smt another
}
----

Причина в том, что в Go 1.13 появилась возможность оборачивать ошибки для добавления дополнительной информации. По сути, мы создаём новую ошибку на базе уже существующей ошибки.

Для строго стиля проверки на ошибку — предопределённая ошибка и созданная (обёрнутая) на основе неё другая новая ошибка — не будут совпадать, так как обернутая ошибка не равна оригинальной предопределённой ошибке.

Функция *errors.Is()*, наоборот, работает путем распаковки ошибок — при необходимости — перед проверкой на совпадения. Если у вас Go 1.13 или новее, лучше использовать *error.Is()*. Это хороший способ защитить код в будущем и предотвратить проблемы, вызванные вами — или любыми пакетами, которые ваш код импортирует.

Существует также другая функция, *errors.As()*, которую вы можете использовать, чтобы проверить, есть ли (у потенциально обернутой — wrapped) ошибки определенный тип. Мы будем использовать эту функцию в будущих уроках.