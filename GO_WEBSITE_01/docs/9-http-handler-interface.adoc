= 9. Интерфейс http.Handler

Обработчик - это объект, который удовлетворяет интерфейсу http.Handler:

[source, go]
----
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
----

Здесь у нас есть объект (структура home), и мы реализовали для неё метод. Теперь наша структура стала обработчиком. Затем можно зарегистрировать этот обработчик с помощью servemux (маршрутизатор HTTP запросов), используя метод Handle

[source, go]
----
type home struct {}

func (h *home) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte("Это моя домашняя страница"))
}

mux := http.NewServeMux()
mux.Handle("/", &home{})
----

==== Функция в качестве обработчика запросов

Сейчас создание объекта только для того, чтобы можно было реализовать для него метод ServeHTTP(), кажется многословным и запутанным. Именно поэтому на практике гораздо чаще обработчики пишутся как обычные функции

[source, go]
----
func home(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte("Моя домашняя страница!"))
}
----

Функция home() является самой обычной функцией. У нее нет метода ServeHTTP(). Так что, по сути она не является обработчиком для HTTP запросов. Но можно превратить функцию в обработчик с помощью использования адаптера *_http.HandlerFunc()_*:

[source, go]
----
mux := http.NewServeMux()
mux.Handle("/", http.HandlerFunc(home))
----

Адаптер http.HandlerFunc() работает путем автоматического добавления метода ServeHTTP() для функции home(). При выполнении, метод ServeHTTP() просто вызывает контент из оригинальной функции home(). Это обходной, но удобный способ заставить обычную функцию соответствовать требованиям интерфейса http.Handler.

==== Объединение обработчиков в цепочку

Вы могли заметить кое-что интересное прямо на старте проекта. Функция http.ListenAndServe() принимает объект http.Handler в качестве второго параметра…

[source, go]
----
func ListenAndServe(addr string, handler Handler) error
----

…но мы передавали servemux вместо http.Handler.

Мы смогли это сделать, потому что у servemux также есть метод ServeHTTP(). Это значит, что он также соответствует требованиям интерфейса http.Handler.

Проще думать о servemux как об особом обработчике, который вместо предоставления ответа передает запрос второму обработчику. Это не такой уж большой скачок, как может показаться на первый взгляд. Объединение обработчиков в цепочку — очень распространенная идиома в Go (которую мы часто будем использовать в будущем).

На самом деле происходит следующее:

1. Когда сервер получает новый HTTP-запрос, он вызывает метод ServeHTTP() от servemux;
2. Метод ServeHTTP() от servemux ищет соответствующий обработчик на основе URL запроса и, в свою очередь, вызывает метод ServeHTTP() данного обработчика.

Можно рассматривать веб-приложение как цепочку из ServeHTTP() методов, вызываемых один за другим.

==== Многопоточная обработка запросов

Важно отметить еще один момент: все входящие HTTP-запросы выполняются в собственной горутине. Для загруженных серверов это означает, что код, загружаемый обработчиками или вызываемый ими, скорее всего будет выполняться параллельно. Это ускоряет работу приложения, но вам нужно знать и защититься от состоянии гонки при доступе к общим ресурсам из обработчиков