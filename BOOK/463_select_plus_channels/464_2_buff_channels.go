package main

import (
	"fmt"
	"strconv"
)

// Буферизованные каналы позволяют планировщику Go быстро размещать
// задания в очереди, чтобы обрабатывать больше запросов. Кроме того,
// их можно использовать в качестве семафоров, позволяющих ограничить
// пропускную способность приложения.
// Представленный здесь метод работает так: все входящие запросы
// перенаправляются на канал, который обрабатывает их по очереди. Когда
// канал завершает обработку запроса, он отправляет исходному
// вызывающему объекту сообщение о том, что канал готов обработать новый
// запрос. Таким образом, емкость буфера канала ограничивает количество
// одновременных запросов, которые этот канал может хранить.

func main() {
	numbers := make(chan int, 5) // канал хранит до пяти целых чисел
	counter := 10

	for i := 0; i < counter; i++ {
		select {
		case numbers <- i:
		default:
			fmt.Println("Not enough space for", i)
		}
	}

	cnt := 1
	for i := 0; i < counter+1; i++ {
		// Пока в канале numbers есть что читать, будет выполняться
		// первая ветвь оператора select. Когда канал numbers пустой,
		// выполняется ветвь default
		select {
		case num := <-numbers:
			fmt.Println(num)
		default:
			fmt.Println("Nothing more to be done! (" +
				strconv.Itoa(cnt) + ")")
			cnt++
			break
		}
	}
}
