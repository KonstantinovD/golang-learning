package main

//  Канал — это механизм коммуникации, который, помимо прочего, позволяет
// обмениваться данными между горутинами.
// Однако здесь есть ряд правил. Во-первых, каждый канал позволяет
// обмениваться данными определенного типа, который называется типом
// элемента канала. Во-вторых, для правильной работы канала необходим
// кто-то, кто будет получать то, что отправляется через канал. Чтобы
// создать новый канал, нужно использовать ключевое слово chan, а чтобы
// его закрыть — вызвать функцию close().
// Наконец, еще одна очень важная деталь: используя канал в качестве
// аргумента функции, можно указать его направление — будет ли этот
// канал использоваться для отправки или получения данных. Это сделает
// программу надежнее: нельзя случайно отправить данные в канал, из
// которого можно только получать данные, или наоборот.

// Записать значение x в канал c очень просто: достаточно написать код
// c <- x. Стрелка показывает направление передачи значения, так что
// у вас не возникнет проблем с этим утверждением, если и x, и c
// имеют одинаковый тип

import (
	"fmt"
	"time"
)

func writeToChannel(c chan int, x int) {
	fmt.Println(x)
	c <- x
	close(c) // закрывает канал, т.е. делает невозможным запись в него
	// второй оператор fmt.Println(x) никогда не выполняется
	fmt.Println(x)
	// ибо оператор c <- x блокирует выполнение остальной части функции
	// writeToChannel(), так как никто не читает то, что было записано
	// в канал c
	// Поэтому, когда оператор time.Sleep(1 * time.Second) завершает
	// работу, программа заканчивает выполнение, не ожидая завершения
	// writeToChannel()
}

func main() {
	c := make(chan int)
	go writeToChannel(c, 10) // выполняется функция как горутина
	time.Sleep(time.Second)  // предоставить время для выполнения функции
}
